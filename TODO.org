#+TODO: TODO(t) POSIBLE(p) POSSIBLE(p) FUTURE(f) | DONE(d!) CANCELED(c!)


* DONE Reflexionar la manera de nombrar las clases
  SCHEDULED: <2018-12-11 mar>
  - State "DONE"       from "TODO"       [2018-12-11 mar 16:12]
* TODO Hacer comparativa de clasificadores
  SCHEDULED: <2018-11-23 vie>
** DONE Crear métodos de accuracy y confusion_matrix
   - State "DONE"       from "TODO"       [2018-11-15 jue 11:53]
** TODO Escribir la clase gender genérica desde lo aprendido en la clase sexmachine
Por ahora valdría con llegar a migrar los métodos necesarios hasta ejecutar accuracy y confusion matrix
** TODO Reescribir todas las clases api heredando de gender
* DONE Estudiar las relaciones entre las variables escogidas
  - State "DONE"       from "TODO"       [2018-12-03 lun 15:58]
Mirar python-examples/matplotlib/corr.py
* TODO Crear la tarea de aprendizaje de dado el string de nombre descubrir nombre y apellidos si los hay
** DONE Crear método guess_surname
   - State "DONE"       from "TODO"       [2018-11-22 jue 16:12]
* DONE Hacer los test requeridos para string2array
  - State "DONE"       from "TODO"       [2018-11-15 jue 11:52]
* FUTURE Meter en guess todos los clasificadores
    def guess(self, name, classifier_type):
    # guess method to check names dictionary and nltk classifier
        guess = ''
        if name in names.words('male.txt'):
#            guess = 'male' # 1
            guess = np.array([1])
        elif name in names.words('female.txt'):
#            guess = 'female' # 0
            guess = np.array([0])
        else:
           if (classifier_type == 'gaussianNB'):
               m = self.bernoulliNB()
               guess = m.predict([[ 0,  0,  1,  0, 21,  0,  0,  0,  0, 34,  2,  0,  0,  0,  0,  0, 0,  0,  0,  5,  0,  0,  0,  0,  0,  2,  0,  0,  0, 34,  1,  0]])
           elif (classifier_type == 'multinomialNB'):
               m = self.multinomialNB()
               guess = m.predict([[ 0,  0,  1,  0, 21,  0,  0,  0,  0, 34,  2,  0,  0,  0,  0,  0, 0,  0,  0,  5,  0,  0,  0,  0,  0,  2,  0,  0,  0, 34,  1,  0]])
           elif (classifier_type == 'bernoulliNB'):
               m = self.bernoulliNB()
               guess = m.predict([[ 0,  0,  1,  0, 21,  0,  0,  0,  0, 34,  2,  0,  0,  0,  0,  0, 0,  0,  0,  5,  0,  0,  0,  0,  0,  2,  0,  0,  0, 34,  1,  0]])
           else: # nltk default
               classifier = self.classifier()
               guess = classifier.classify(self.features(name))
        return guess
* DONE Plantearse renombrarlo a damegender
  SCHEDULED: <2018-11-16 vie>
  - State "DONE"       from "TODO"       [2018-12-10 lun 12:55]
* DONE guess en Gendernamsor
  - State "DONE"       from "TODO"       [2018-12-03 lun 15:58]
    # def guess(Gender, name, surname, binary=False):
    # # guess method to check names dictionary and nltk classifier
    #     guess = super(Gender, self).gender()
    #     guess = ''
    #     if name in names.words('male.txt'):
    #         if binary:
    #             guess = 1
    #         else:
    #             guess = 'male'
    #     elif name in names.words('female.txt'):
    #         if binary:
    #             guess = 0
    #         else:
    #             guess = 'female'
    #     else:
    #         r = requests.get('https://api.namsor.com/onomastics/api/json/gender/'+ name +'/' + surname)
    #         d = json.loads(r.text)
    #         if binary:
    #             if (d['gender']=='female'):
    #                 guess = 0
    #             elif (d['gender']=='male'):
    #                 guess = 1
    #             else:
    #                 guess = 2
    #         else:
    #             guess = d['gender']
    #     return guess
* DONE Escribir comando para adivinar un nombre
  - State "DONE"       from "TODO"       [2018-11-19 lun 19:18]
* DONE Escribir comando git2gender.py
  SCHEDULED: <2018-11-20 mar>
  - State "DONE"       from "TODO"       [2018-11-22 jue 16:12]
Dada una url obtener número y porcentaje de hombres y mujeres
** TODO Escribir método string2name
Dada una cadena con espacios en blanco:
1. Crea un array.
2. Recorre el array hasta encontrar el primer nombre.
2.1 Es nombre si no está en la lista de apellidos.
3. Devuelve el primer nombre.

* DONE Escribir comando gender2csv.py
  SCHEDULED: <2018-11-20 mar>
  - State "DONE"       from "TODO"       [2018-11-22 jue 16:12]
Dado un fichero csv obtener número y porcentaje de hombres y mujeres
* DONE Hay un problema con los acentos
  - State "DONE"       from "TODO"       [2018-11-22 jue 08:30]
Probar
$ python3 main.py Inés
$ python3 main.py Ines
* TODO Hay un problema con los nombres que aparecen en male.txt y female.txt
Probar
$ python3 main.py Andrea
Para esto lo mejor es devolver una probabilidad. Usar INE.es puede ser una opción.
* DONE Meter en el requirements la dependencia de hyphenation
  SCHEDULED: <2018-11-20 mar>
  - State "DONE"       from "TODO"       [2018-11-22 jue 16:11]
* DONE Reescribir num_males y num_females con el método list_commiters de GenderGit
  SCHEDULED: <2018-11-22 jue>
  - State "DONE"       from "TODO"       [2018-11-22 jue 16:10]
* DONE Escribir tests para main.py, csv2gender y git2gender
  SCHEDULED: <2018-11-23 vie>
  - State "DONE"       from "TODO"       [2018-11-29 jue 09:48]
* TODO Para csv2gender:
  SCHEDULED: <2018-11-24 sáb>
** en file deberías reconocer:
+ [ ] formato csv
+ [ ] tiene las rows importantes
** en sexmachine
+ [ ] trabajar por path en vez de all y partial
+ [ ] detectar si el fichero existe
* TODO Echar un vistazo a https://www.nameapi.org/en/developer/
  SCHEDULED: <2018-11-30 vie>
* DONE En csv
  - State "DONE"       from "TODO"       [2018-12-03 lun 15:57]
  first_letter; last_letter; a; b; c; d; e; f; g; h; i; j; k; l; m; n; o; p; q; r; s; t; u; v; w; x; y; z; vocals; consonants; first_letter_vocal; last_letter_vocal; syllables
* TODO Mejora corr.py para determinar si las variables son independientes
+ [ ] Separar variables categóricas y no categóricas
+ [ ] Crear una gráfica para variables categóricas
+ [ ] Crear una gráfica para variables no categóricas
